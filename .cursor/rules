## Cursor Autopilot (safe, non-blocking)

### Goals
- Keep moving forward with minimal interruptions.
- Never take irreversible/destructive actions without explicit approval.
- When blocked, **log and continue** (don't stall on "Resume/Try again" loops).

### Non-negotiables (repo contract)
- Follow `NON_NEGOTIABLES.md`.
- Follow `MVP_GOALS_FINAL_LOCKED.md` - MVP goals are LOCKED and take precedence.
- Use `CURSOR_OPERATIONAL_GUIDE.md` as the workflow for testing/stability.

### MVP Goals Alignment (CRITICAL - 2026-01-25)
- **MVP Definition**: "A user authorizes payment once and always gets either a fully delivered report (or bundle) or no charge — with zero stuck states and zero money leakage."
- **Core Intent**: Stability > cleverness, Predictability > speed, One correct path > many flexible ones
- **No cron-for-correctness**: System must be correct without cron jobs
- **No automatic retries**: Failures are terminal and visible
- **Worker is the only execution path**: Frontend never generates reports
- **Payment captured only after success**: Never charge unless report/bundle is fully delivered
- **Bulk reports allowed with strict conditions**: Only if all conditions met (see MVP_GOALS_FINAL_LOCKED.md)
- **Yearly analysis flakiness acknowledged**: Needs strict timeouts, validation, fallback "lite yearly" mode
- **Rollback to last stable build**: Priority = stability > scope purity

### Non-blocking fallback ladder (what to do next when blocked)
When a step would trigger a permission popup, “Allow popups safely”, “Resume”, or “Try again”, do **not** wait idle. Switch immediately to the next safest useful work in this order:
- **(1) Continue with safe, offline work**: read/search code, analyze, narrow scope, identify the minimal files to touch, and draft the exact changes.
- **(2) Prepare patch-level output**: write the exact diffs/edits conceptually (file paths + snippets), so the work is ready to apply once unblocked.
- **(3) Improve the plan**: break the task into smaller batches (≤ 5 files) and queue the next batch.
- **(4) Update logs**: record progress in `CURSOR_PROGRESS.md` and any required clicks/approvals in `CURSOR_ACTIONS_REQUIRED.md`.
- **(5) Only if truly blocked** (nothing safe remains): ask for the minimal single approval needed, once.

### Execution style
- Work in small batches: **≤ 5 files changed per batch**, one concern per batch.
- **CRITICAL (ChatGPT Feedback)**: Work in batches of **one file at a time** to minimize "Confirm edit" prompts.
- Avoid repo-wide scans/refactors unless explicitly asked.
- Prefer minimal diffs; do not reformat unrelated code.
- If a step is long-running, run it in the background when possible and continue with other work.

### Autopilot Non-Negotiables (ChatGPT Feedback - Minimize Interruptions)
- **No broad edits**: Max 1–3 files per change set (prefer 1 file at a time).
- **No refactors while fixing bugs**: Fix the bug with minimal surface area.
- **Always green before next change**: Must pass `npm run ci:critical` after every change set.
- **If confirmation required**: write `CURSOR_ACTIONS_REQUIRED.md` first, then pause.
- **Never proceed after connection error** without logging next actions to `CURSOR_ACTIONS_REQUIRED.md`.
- **Single-file edits**: When possible, edit one file at a time to reduce "Confirm edit" prompts.
- **Consolidate edits**: If multiple files need changes, batch them into ONE accept step when possible.

### Critical Preview Page Rules (ChatGPT Feedback)
- **No refactors in preview/page.tsx** unless tests are added/updated first.
- **Any change touching**:
  - `preview/page.tsx`
  - `/api/ai-astrology/generate-report`
  - subscription routes
  must pass: `npm run ci:critical` locally.
- **Never add new import path** without updating the "build-imports" test.
- **Polling loops may only terminate on**: abort signal, unmount, attemptKey changed, completed/failed state.
- **Do not use UI state** (`isProcessingUI`, `isProcessingUIRef`) to stop polling - UI state can flip during first-load.
- **Timer monotonic**: never clear `loadingStartTimeRef.current` during active generation attempt.

### Single Orchestration Owner Rule (ChatGPT Feedback - CRITICAL)
- **ONE owner for generation start**: Only ONE code path is allowed to call `generationController.start()` automatically.
- **No premature auto-recovery**: Auto-recovery must ONLY run when:
  - `generationController.status === "error"` OR `elapsedSeconds > 120`
  - AND `hasAutoGeneratedRef.current === true` (actual attempt happened)
  - AND it has not already auto-recovered
  - NEVER on first load (fresh session)
- **Recovery is manual only**: Recovery is now ONLY available via manual "Retry" button - never automatic on first load.
- **No multiple auto-start mechanisms**: Do NOT add:
  - Auto-recovery useEffect that starts generation
  - Multiple auto-generate effects that race
  - Overlapping triggers (paid report setTimeout start + verify callback start + recovery start)
- **Singleflight guard required**: Any call to `generationController.start()` must be behind a singleflight guard (e.g., `startGenerationOnce(reason)`).
- **Why this rule exists**: Multiple auto-start mechanisms race on first load, causing timer resets and stuck states. Only one owner prevents this.

### Single Orchestrator Rule (ChatGPT Feedback - CRITICAL - UPDATED)
- **Preview page must use exactly ONE orchestrator (controller)**: No legacy generation/polling logic allowed.
- **session_id is NOT state**: UI must NOT use URL params (`session_id`, `reportId`, `auto_generate`) to infer processing state.
- **Processing state must come from controller status ONLY**: `isProcessingUI` must be driven by:
  - Controller status: `["verifying", "generating", "polling"].includes(controller.status)` (when using controller)
  - Bundle processing: `bundleType && bundleReports.length > 0 && bundleGenerating` (temporary legacy path, gated to bundles only)
  - NEVER from URL params (session_id, reportId, auto_generate)
- **Bundle processing gate**: `bundleProcessing` can ONLY affect bundle reports. If `bundleProcessing` is true but `reportType` is not a bundle, log invariant violation.
- **Invariant**: If `processing === false`, UI must NEVER show "Generating...", even if URL contains `session_id`.
- **ReturnTo contract**: Any page that redirects to `/ai-astrology/input` must be returned back to `returnTo` after submission.
- **Invariant tests are blocking**: `test:critical` must include:
  - `critical-first-load-paid-session.spec.ts` (first-load paid session generation)
  - `stale-session-retry.spec.ts` (stale session handling)
  - `preview-no-processing-without-start.spec.ts` (session_id ≠ processing canary)
  - `subscription-returnTo.spec.ts` (subscription returnTo loop)
  - `preview-requires-input.spec.ts` (preview redirect to input when no input_token)
  - `purchase-noop-prevented.spec.ts` (purchase redirect to input, not silent return)
  - `subscription-input-token-flow.spec.ts` (subscription accepts input_token, cleans URL)
- **If Cursor changes preview/subscription/input**: Must run `npm run test:critical` and paste output into `CURSOR_PROGRESS.md`.

### Input Ownership & Redirect Invariants (ChatGPT Feedback - CRITICAL - 2026-01-17)
- **NO redirect gating based on reportType**: Preview page must ALWAYS redirect to `/input` if no input + no valid input_token, regardless of `reportType` in URL.
- **NO silent returns from purchase/subscribe handlers**: If input is missing, handlers MUST redirect to `/input` with `returnTo`, NEVER silently return.
- **Unified input_token mechanism**: ALL flows (preview, subscription) must use `input_token` as primary source, sessionStorage as fallback cache only.
- **Subscription must accept input_token**: Subscription page MUST check `input_token` in URL first, load from API, then clean URL. sessionStorage is fallback only.
- **Input page must respect flow=subscription**: If `flow=subscription`, input page MUST redirect to `/ai-astrology/subscription?input_token=...` (not preview).
- **Preview redirect invariant**: If no input + no valid input_token → redirect to `/input` ALWAYS (with returnTo = exact preview URL).
- **Purchase redirect invariant**: If `handlePurchase()` has no input → redirect to `/input?reportType=...&returnTo=...` ALWAYS, never silently return.
- **Token error handling**: If `input_token` fetch fails (410/500), show real error UI with "Start again" button that navigates to input, not infinite redirecting.
- **Redirect timeout invariant (CRITICAL - 2026-01-17 21:15)**: Preview must NEVER show "Redirecting..." for > 2 seconds. If redirect hasn't happened by then, switch to error UI with "Start again" + "Copy debug Ref". This protects from router.push never executes / blocked / hydration edge cases and provides logs.
- **returnTo loop prevention**: If `returnTo` points to `/ai-astrology/input` or already contains `flow=subscription`, override to safe default:
  - Subscription flow default: `/ai-astrology/subscription`
  - Report flow default: `/ai-astrology/preview?reportType=<x>`
  This avoids "input → subscription → input → ..." loops in weird partial states.
- **Single-flight guard for purchase/subscribe**: Purchase/Subscribe handlers MUST use single-flight guard (`isSubmittingRef.current`) to prevent double-clicks from causing duplicate API calls. Set `true` immediately, clear on `finally`/route change.
- **Why these rules exist**: Previous iterations "patched symptoms" (timer, controller state) but real failures are routing/state ownership bugs. Unified input ownership prevents "Redirecting..." dead states and "nothing happens" issues.

### NO SILENT RETURNS & NO DEAD REDIRECTING UI (ChatGPT Feedback - CRITICAL - 2026-01-17 22:00)
- **NO SILENT RETURNS IN CLICK HANDLERS**: If a handler can't proceed (missing input/token), it MUST:
  - Navigate to the correct page (e.g., `/ai-astrology/input?reportType=...&flow=...&returnTo=...`), OR
  - Show a visible error state (e.g., `setError("Please enter birth details to subscribe.")`).
  - NEVER silently return (`if (!input) return;` is FORBIDDEN).
- **NO "REDIRECTING UI" WITHOUT REAL NAVIGATION**: "Redirecting..." screens may ONLY render when:
  - A redirect has been explicitly initiated (`redirectInitiatedRef.current === true`), meaning `router.push()` or `router.replace()` has already been called.
  - NEVER show "Redirecting..." just because `reportType` is in URL or `hasReportTypeInUrl` is true.
  - If redirect hasn't been initiated yet, show "Enter Your Birth Details" card OR let useEffect trigger redirect (don't show "Redirecting..." prematurely).
- **Preview must set input state IMMEDIATELY after loading input_token**: When preview receives `input_token`, it MUST:
  1. Load it (fetch from API)
  2. Set input state IMMEDIATELY (`setInput(inputData)`, `setReportType(...)`, etc.) - BEFORE any redirect logic
  3. Only then clean URL (optional, but don't do it if it would cause redirect loop)
  - This prevents "purchase → input → preview → input" loop.
- **Release gate must include new tests**: `npm run test:critical` MUST include:
  - `preview-no-dead-redirecting.spec.ts` (preview with reportType but no input redirects within 2s)
  - `subscription-noop-prevented.spec.ts` (subscribe button redirects to input when no input exists)
  - `purchase-redirects-to-input-then-back.spec.ts` (purchase → input → preview with input_token → preview does NOT redirect back to input)
- **Why these rules exist**: Root cause of "Redirecting..." dead-state and "nothing happens" issues is:
  - `hasReportTypeInUrl` gating redirect (causing "Redirecting..." to show forever)
  - Silent returns in click handlers (causing "nothing happens" when input missing)
  - Preview not setting input state immediately after loading input_token (causing redirect loops)

### PRIVATE BETA GATING (ChatGPT Feedback - CRITICAL - 2026-01-17 23:30)
- **Production-only gating**: Private beta gating is enabled when `NEXT_PUBLIC_PRIVATE_BETA === "true"`. In preview/dev, gating is disabled by default (env var not set or false).
- **Server-side allowlist only**: Allowlist is stored server-side only (`src/lib/betaAccess.ts`). MUST NOT be imported in client components (would leak allowlist in bundle).
- **Dual enforcement (UI + API)**: Gate enforcement happens at BOTH:
  - **UI routes**: Middleware redirects `/ai-astrology/*` to `/ai-astrology/access` (unless cookie present or path is `/access`)
  - **API routes**: Middleware returns 401 JSON for `/api/ai-astrology/*` and `/api/billing/*` (unless cookie present)
- **No client-only gating**: Client-side checks are NOT sufficient. Middleware must enforce gating server-side.
- **HttpOnly cookie**: Beta access cookie (`beta_access=1`) is HttpOnly (set by `/api/beta-access/verify`), TTL 7 days.
- **Access verification**: `/ai-astrology/access` page collects birth details, calls `/api/beta-access/verify`, sets cookie on match, redirects to returnTo or `/ai-astrology`.
- **Matching robustness**: Normalization functions handle various input formats:
  - Name: case-insensitive, collapse spaces
  - DOB: accept "dd mon yyyy" or "YYYY-MM-DD" format
  - Time: accept "09:40 pm" or "21:40" format (12h/24h)
  - Place: case-insensitive, allows "Noamundi, Jharkhand" to match "Noamundi, Jharkhand, India" (includes match)
  - Gender: accept "Male"/"Female" or "M"/"F"
- **Verification logging**: Server logs `[BETA_ACCESS] ok=true/false, requestId, ip` (no PII like names/dob).
- **Tests required**: `test:critical` and `release:gate` MUST include:
  - `beta-access-blocks-ai-astrology.spec.ts` (redirects when no cookie)
  - `beta-access-allows-after-verify.spec.ts` (access after valid verification)
  - `beta-access-blocks-api.spec.ts` (401 for API routes when no cookie)
  - `tests/unit/betaAccess.test.ts` (normalization/matching unit tests)
- **Removal**: To disable gating, set `NEXT_PUBLIC_PRIVATE_BETA=false` or unset env var, redeploy.

### CRITICAL REDIRECT LOOP & STUCK SCREEN FIXES (2026-01-18)
- **Redirect check must wait for token loading**: Preview/subscription pages MUST only check redirect AFTER `tokenLoading === false`. Token fetch is authoritative - wait for it to complete before any redirect decisions.
- **Hard navigation required**: ALL redirects MUST use `window.location.assign()` instead of `router.push()` to prevent race conditions and stuck "Redirecting..." screens. Hard navigation is synchronous and guarantees navigation completes.
- **Subscription returnTo handling**: After loading token, subscription page MUST check for `returnTo` parameter in URL. If valid, navigate to it. Only clean URL after navigation completes.
- **Subscribe button token loading check**: Subscribe button MUST check `tokenLoading` before allowing subscribe. Button MUST be disabled while `tokenLoading === true`. Show loading state.
- **Never reset hasRedirectedRef after token loads**: Once token is loaded and input state is set, NEVER reset `hasRedirectedRef` to prevent redirect loops.
- **Redirect initiated flag**: Only show "Redirecting..." UI when `redirectInitiatedRef.current === true`. Clear flag after navigation completes.
- **E2E tests required**: `test:critical` MUST include:
  - `no-redirect-loop-after-input.spec.ts` (verifies no redirect back to input after entering details)
  - `subscription-journey-returnTo.spec.ts` (verifies subscription journey returns to dashboard)
- **Why these rules exist**: Redirect loops and stuck "Redirecting..." screens were caused by race conditions between token loading and redirect checks, and using soft navigation (`router.push`) which doesn't guarantee completion.

### TOKEN FETCH AUTHORITATIVE & PURCHASE READY (Step 1-4 - CRITICAL - 2026-01-18)
- **Token fetch must be authoritative (Step 1)**: Preview/subscription pages MUST use `tokenLoading` state to prevent redirects while token is being fetched. Redirect logic MUST check `!tokenLoading && !inputToken && !input` before redirecting. NEVER redirect while `tokenLoading === true`.
- **Loading UI while token fetches (Step 1)**: While `tokenLoading === true`, preview/subscription MUST show "Loading your details..." UI (NOT "Redirecting..."). This prevents redirect loops and provides clear feedback.
- **Token fetch lifecycle logging (Step 1)**: Preview/subscription MUST log:
  - `[TOKEN_GET] start ...suffix` when token fetch starts
  - `[TOKEN_GET] ok status=200` when token fetch succeeds
  - `[TOKEN_GET] fail status=400` when token fetch fails
  - `[REDIRECT_TO_INPUT] reason=missing_input_no_token` when redirecting (only if tokenLoading=false)
- **Purchase button must check tokenLoading (Step 2)**: `handlePurchase()` MUST check `tokenLoading` before proceeding. If `tokenLoading === true`, return early (do NOT redirect). Purchase button MUST be disabled when `tokenLoading === true` (add to `disabled={loading || tokenLoading || !refundAcknowledged}`).
- **Purchase click logging (Step 2)**: `handlePurchase()` MUST log `[PURCHASE_CLICK] {hasInput, hasToken, tokenLoading}` for visibility.
- **Subscription flow already correct (Step 3)**: Subscription page already redirects to input with `flow=subscription`. Input page already redirects to subscription with `input_token` when `flow=subscription`. No changes needed.
- **E2E tests required (Step 4)**: `test:critical` MUST include:
  - `token-get-required.spec.ts` (GET `/api/ai-astrology/input-session?token=` occurs within 2s after navigation)
  - `no-redirect-while-token-loading.spec.ts` (preview/subscription does NOT redirect while tokenLoading=true, shows "Loading your details...")
- **Why these rules exist**: Redirect loops occur when redirect logic runs before token fetch completes. Token fetch must be authoritative - no redirects allowed while `tokenLoading === true`.

### HARD NAVIGATION & SERVICE WORKER STABILIZATION (ChatGPT Feedback - CRITICAL - 2026-01-17 22:45)
- **Input redirect must use window.location.assign (NOT router.push)**: After input submit, MUST use `window.location.assign(fullUrl)` for hard navigation. This guarantees query params survive and avoids Next soft-navigation keeping stale state. NEVER use `router.push()` for input → preview/subscription redirects.
- **Service worker disabled during stabilization**: Service worker MUST be gated behind `NEXT_PUBLIC_ENABLE_PWA === "true"` env flag. Default: disable in all environments until flows are stable. If `NEXT_PUBLIC_ENABLE_PWA` is false, unregister any existing service workers. This prevents SW from breaking deploy verification by caching old JS.
- **Build ID stamp required**: Footer MUST display build ID (`NEXT_PUBLIC_BUILD_ID` or `VERCEL_GIT_COMMIT_SHA`). Console MUST log `[BUILD] buildId` on page mount. This proves deployed JS is active (not cached by SW/browser).
- **Token visibility logging**: Preview/subscription MUST log:
  - `[TOKEN_IN_URL] token` on mount (or "none")
  - `[TOKEN_FETCH_START] ...suffix` when starting token fetch
  - `[TOKEN_FETCH_RESPONSE] {ok, status, error}` when token fetch completes
  - This makes token fetch visible in DevTools/console for debugging.
- **Input redirect logging**: Input page MUST log `[INPUT_REDIRECT] fullUrl` before redirect. This helps debug if redirect URL is correct.
- **No service worker while stabilizing checkout/routing**: Service worker MUST be disabled during stabilization. Re-enable only after all flows are verified stable in production.
- **Release gate must include input-token-in-url test**: `npm run test:critical` MUST include:
  - `input-token-in-url-after-submit.spec.ts` (input submit → URL contains input_token AND network call visible AND no redirect loop)

### Technical Debt (Tracked for Future Refactor)
- **setTimeout autostart** (preview/page.tsx, line ~1242):
  - **Status**: ✅ Guarded and documented, acceptable for production
  - **Guards**: `hasAutoGeneratedRef.current`, early returns, cleanup on unmount, never re-scheduled
  - **TODO**: Replace with `useEffect(() => startIfNeeded(), [attemptKey, auto_generate])` for better determinism
  - **Rationale**: Refactoring now risks re-introducing first-load races. Tests will catch regressions if guards fail.
  - **Do NOT refactor casually**: This is tracked technical debt. Any refactor must:
    - Include comprehensive E2E tests
    - Verify no regressions in first-load scenarios
    - Update this TODO with completion date

### Production Serverless Rules (ChatGPT Feedback - CRITICAL)
- **Single-surface changes**: one bug = one subsystem. No refactors unless requested.
- **No UI timer tweaks until API lifecycle is proven**: fix server first, then UI.
- **Serverless timeout config**: Any route that can exceed default execution time MUST export:
  - `export const runtime = "nodejs";`
  - `export const maxDuration = 180;` (or higher for complex reports)
  - `export const dynamic = "force-dynamic";`
- **Heartbeat required**: Long-running generation MUST update `updated_at` every 15-20s to prevent stuck "processing" status.
- **Always mark failed on error**: Catch/finally MUST call `markStoredReportFailed` to prevent reports stuck in "processing".
- **Every change must pass, locally**:
  - `npm run type-check`
  - `npm run build`
  - `npm run test:critical` (Playwright critical invariants)
- **If a fix touches routing/session/subscription**: it must add/adjust an E2E test.
- **If any one of these fails**: stop and write in `CURSOR_ACTIONS_REQUIRED.md` rather than "try random fixes".

### Build & Environment Rules (ChatGPT Feedback - CRITICAL)
- **Never conclude "not code issue" without proof**: Only claim sandbox/environment restriction if:
  - Failure is reproducible on a known-good runner (local/CI) AND
  - Code path reads forbidden resources (provide exact file+line for every EPERM cause)
- **Build must NOT require .env.local**: Next.js builds should succeed without `.env.local` file. Use `process.env.*` only, validate via `.env.example` + schema (zod/envalid), never `fs.readFileSync(".env.local")`.
- **VAPID key dependency**: Push/VAPID key must read ONLY from `process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY`. If not present: disable push features gracefully (no crash, no build fail).
- **Test stages split correctly**: Tests must be split into independent gates:
  - `test:unit` (no network)
  - `test:integration` (mock external network)
  - `test:e2e` (only in CI runners that support browsers - can be skipped safely when unsupported)
- **When claiming EPERM/sandbox**: Must provide exact file+line where code tries to read restricted resource. No proof = no acceptance.

### If the model/provider fails (Try again / Resume)
- Retry with exponential backoff: **30s, 60s, 120s** (3 attempts total).
- If still failing after 3 retries:
  - Write exact pending steps into `CURSOR_ACTIONS_REQUIRED.md` and stop.
  - Include: file names, change intent, why it is safe, exact next commands.
  - Do NOT continue making changes after connection error without logging.
- Never block waiting for the user; keep progressing on non-blocked work.
- **Root cause fixes** (to prevent connection errors):
  - Check VPN/proxy settings (disable or allowlist Cursor + API provider domains).
  - Verify OpenAI key rate limit/quota/billing/model mismatch.
  - Reduce concurrent agent actions: keep to 1–2 parallel tasks max.

### Approvals (hard stops)
- Always ask before:
  - running terminal commands (unless they match an allowlist you already trust),
  - installing dependencies,
  - deleting files,
  - editing secrets/env files,
  - any network/external API access,
  - **git push** (commits are fine, but always get approval before push).

### When an approval/popup appears (Confirm edit / Accept / Resume / Try again)
- **CRITICAL (ChatGPT Feedback)**: Do NOT ask for clicks repeatedly.
- If "Confirm edit" / "Accept" prompt appears:
  - **STOP making further changes** immediately.
  - Write summary to `CURSOR_ACTIONS_REQUIRED.md` including:
    - File name(s)
    - Change intent
    - Why it is safe
    - Exact next steps after acceptance
  - Wait for a single "Accept", then continue automatically with the next steps.
  - **Consolidate all pending edits into ONE accept step** when possible.
- If "Connection Error" / "Resume" / "Try again" appears:
  - Retry with exponential backoff (30s, 60s, 120s).
  - If still failing: write exact pending steps into `CURSOR_ACTIONS_REQUIRED.md` and stop.
- If it's optional: **skip it** and continue.
- If it blocks progress (common in auth flows): record it in `CURSOR_ACTIONS_REQUIRED.md` with:
  - what prompt appeared,
  - where (which screen/tool),
  - what exact click/setting is needed,
  - why it's needed.
  - the safest alternative (e.g., "Open in browser" for auth) if available.

### Mandatory logging
- After each batch, update `CURSOR_PROGRESS.md`:
  - what changed,
  - what remains,
  - what is blocked + the minimal approval needed.
- **After each successful green CI gate**: Update `CURSOR_PROGRESS.md` with:
  - what changed,
  - which tests passed.
- **Run checkpoint script**: After every change, run `bash scripts/cursor-checkpoint.sh` (if available).
  - This runs: typecheck → build → critical tests
  - Writes output + next steps into `CURSOR_PROGRESS.md`
  - If failure: writes "what to do next" into `CURSOR_ACTIONS_REQUIRED.md`

### MVP System Rules (CRITICAL - 2026-01-25)
- **Frontend never generates reports**: All heavy work runs async via worker
- **Worker is the only execution path**: No frontend generation allowed
- **Payment is captured only after success**: Capture happens only after single report → completed OR bundle → all items completed
- **Failures are terminal and visible**: On failure, PaymentIntent is cancelled immediately, status = failed, no background retry
- **Refreshing the page must not change backend state**: Preview page is idempotent - reload resumes polling, never re-enqueues jobs automatically
- **No build is pushed unless build + tests are green**: Mandatory CI + pre-push gate
- **No new abstractions without explicit approval**: Keep system simple and predictable
- **Same input must always produce same outcome**: Deterministic behavior required
- **Any change violating these is reverted immediately**

### MVP Bulk Reports Conditions (CRITICAL - 2026-01-25)
Bulk is allowed **only if all below are true**:
- Bundle behaves as one logical unit
- Payment capture happens only after entire bundle succeeds
- No partial delivery to user
- One retry applies to the whole bundle
- UI sees one bundle status, not per-item complexity
**If any condition is broken → bulk is frozen.**

### MVP Yearly Analysis Special Rules (CRITICAL - 2026-01-25)
- **Known flakiness acknowledged**: Yearly analysis had known flakiness in last stable build
- **Strict requirements**:
  - Strict timeouts
  - Validation
  - Fallback "lite yearly" mode if needed
- **Never break the entire order**: If safe degradation is possible, use it
- **Never block on perfect yearly report**: Graceful degradation > perfect depth

### MVP Retry Rules (CRITICAL - 2026-01-25)
- **Retry allowed only if**:
  - `status = failed`
  - `retry_count = 0`
  - within 24h
- **Retry behavior**:
  - reuse same order
  - reuse same PaymentIntent (if valid)
  - one manual retry max
- **After retry**: Order becomes terminal
- **No automatic retries**: All retries are manual user-initiated only

### Release Gate (ChatGPT Feedback - CRITICAL)
### Production Readiness Rules (ChatGPT Feedback - CRITICAL)
- **Never claim "production-ready"** unless ALL of the following are true:
  1. **DB migration executed**: Required Supabase tables/columns are created
  2. **Release gate passed in CI/Vercel**: `npm run release:gate` must pass in real runner (not just local)
     - `npm run type-check` ✅
     - `npm run build` ✅
     - `npm run test:critical` ✅
  3. **Manual prod verification completed**: All 3 critical flows tested in production:
     - Purchase Year Analysis → redirects to Stripe OR shows error within 15s
     - Free Life Summary → no redirect loop, reaches preview
     - Monthly subscription → subscribe redirects to Stripe; return sets status
- **release:gate** runs: `npm run type-check && npm run build && npm run test:critical`
- **Lint-free and type-check passing is NOT enough**: Must pass release gate in CI/Vercel and manual prod verification
- **Rationale**: Prevents future "it passed type-check so it's fine" mistakes.
- **Do NOT skip**: Since Cursor sometimes only runs type-check, this ensures all critical checks pass.
- **ChatGPT Verdict**: "This alone will save you days in the future." - Do not change.
- **Not allowed to mark a fix "verified"** unless `release:gate` passes in a real runner (CI/Vercel).
- **If build is blocked**, Cursor must instead fix the build to not depend on local env files (e.g., `.env.local`).
- **Do NOT accept "sandbox blocked"** without providing exact file+line where code tries to read restricted resources.

### Atomic Generation Invariant (ChatGPT Feedback - CRITICAL)
- **NO setTimeout autostart allowed** on preview generation (lines ~1266, ~1675 must be removed)
- **One entrypoint only**: Preview generation can only start via `startGenerationAtomically()`
- **Atomic invariant (MUST HOLD)**:
  - Within 1000ms of mount when `auto_generate=true`:
  - `controller.status` becomes `verifying|generating|polling` OR `failed`
  - Must NEVER remain `idle` while UI shows "Generating"
  - Timer must start ONLY when `controller.status` enters `verifying`
  - On failure, UI must show Retry and timer stops
- **Implementation**: `startGenerationAtomically()` must be called from a single `useEffect` keyed ONLY by `attemptKey` (`session_id + reportType + auto_generate=true`)
- **No PR can claim "fixed"** unless `release:gate` passes and atomic E2E is green
- **Surgical changes only**: Only touch preview autostart + controller start path (no large refactors)

### Baseline Freeze (ChatGPT Feedback - CRITICAL)
- **Current Baseline**: 2026-01-17 (Ship-ready baseline established)
- **Freeze Policy**:
  - ✅ No refactors of core flows (preview generation, subscription, polling)
  - ✅ No "cleanup" without explicit approval
  - ✅ Only additive features allowed
  - ✅ Any core flow change must pass `npm run release:gate`
- **Technical Debt**: setTimeout autostart is being REMOVED (atomic generation fix)
- **ChatGPT Verdict**: "You've turned a fragile, emergent system into a governed, deterministic one."

### Stabilization Mode (ChatGPT Feedback - CRITICAL)
**If the user says "run all tests" or "stabilize build":**
- Enter **Stabilization Mode**
- Follow PHASE 0 → PHASE 4 exactly
- Do not exit early

**PHASE 0 — Freeze Scope**:
- ❌ Do NOT add new features
- ❌ Do NOT refactor unrelated code
- ❌ Do NOT change UI copy/styles
- ✅ Only fix what is required to pass tests and stabilize runtime behavior

**PHASE 1 — Full Test Execution (Mandatory)**:
Run all of the following, in order (do NOT skip any step):
1. `npm run type-check`
2. `npm run build`
3. `npm run test`
4. `npm run test:critical`
5. `npm run ci:critical`

**PHASE 2 — Failure-Driven Fix Loop**:
For each failure:
1. **Identify**:
   - ❓ Is the test wrong? (flaky, outdated, missing invariant)
   - ❓ Or is the code wrong? (regression, race condition, broken contract)
2. **Apply minimal fix**:
   - Change ≤ 5 files
   - Touch only files directly involved in the failure
3. **If a test failed to catch a real bug**:
   - Enhance the test to cover the real user-journey invariant
   - Never weaken assertions
4. **Re-run all tests again from Phase 1**

Repeat until everything passes.

**PHASE 3 — Runtime Stability Verification**:
After tests pass:
- Manually simulate (code-level, not browser clicks):
  - First-load report generation
  - Polling convergence (processing → complete/failed)
  - Subscription create → verify → cancel
- Confirm no infinite loops, no timer resets, no silent exits

**PHASE 4 — Lock the Win**:
When stable:
1. Update `CURSOR_PROGRESS.md`:
   - What failed
   - What changed
   - What fixed it
2. Update `CURSOR_ACTIONS_REQUIRED.md`:
   - Only if human action is required (keys, Stripe dashboard, etc.)
3. **STOP** - Do not continue improving or refactoring

**ABSOLUTE NON-NEGOTIABLE RULES**:
- If any test fails → you are NOT done
- If build fails → revert and fix
- If a fix breaks another test → revert and re-iterate
- Never silence errors
- Never bypass CI gates
- Never assume "second load works" is acceptable

**Success condition**: `npm run ci:critical` passes AND no infinite loading states are possible.


