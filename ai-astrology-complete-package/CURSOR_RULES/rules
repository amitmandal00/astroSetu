# Cursor Rules

This file contains the Cursor autopilot rules.
In your actual project, these should be at `.cursor/rules`.

## Cursor Autopilot (safe, non-blocking)

### Goals
- Keep moving forward with minimal interruptions.
- Never take irreversible/destructive actions without explicit approval.
- When blocked, **log and continue** (don’t stall on “Resume/Try again” loops).

### Non-negotiables (repo contract)
- Follow `NON_NEGOTIABLES.md`.
- Use `CURSOR_OPERATIONAL_GUIDE.md` as the workflow for testing/stability.

### Non-blocking fallback ladder (what to do next when blocked)
When a step would trigger a permission popup, “Allow popups safely”, “Resume”, or “Try again”, do **not** wait idle. Switch immediately to the next safest useful work in this order:
- **(1) Continue with safe, offline work**: read/search code, analyze, narrow scope, identify the minimal files to touch, and draft the exact changes.
- **(2) Prepare patch-level output**: write the exact diffs/edits conceptually (file paths + snippets), so the work is ready to apply once unblocked.
- **(3) Improve the plan**: break the task into smaller batches (≤ 5 files) and queue the next batch.
- **(4) Update logs**: record progress in `CURSOR_PROGRESS.md` and any required clicks/approvals in `CURSOR_ACTIONS_REQUIRED.md`.
- **(5) Only if truly blocked** (nothing safe remains): ask for the minimal single approval needed, once.

### Execution style
- Work in small batches: **≤ 5 files changed per batch**, one concern per batch.
- **CRITICAL (ChatGPT Feedback)**: Work in batches of **one file at a time** to minimize "Confirm edit" prompts.
- Avoid repo-wide scans/refactors unless explicitly asked.
- Prefer minimal diffs; do not reformat unrelated code.
- If a step is long-running, run it in the background when possible and continue with other work.

### Autopilot Non-Negotiables (ChatGPT Feedback - Minimize Interruptions)
- **No broad edits**: Max 1–3 files per change set (prefer 1 file at a time).
- **No refactors while fixing bugs**: Fix the bug with minimal surface area.
- **Always green before next change**: Must pass `npm run ci:critical` after every change set.
- **If confirmation required**: write `CURSOR_ACTIONS_REQUIRED.md` first, then pause.
- **Never proceed after connection error** without logging next actions to `CURSOR_ACTIONS_REQUIRED.md`.
- **Single-file edits**: When possible, edit one file at a time to reduce "Confirm edit" prompts.
- **Consolidate edits**: If multiple files need changes, batch them into ONE accept step when possible.

### Critical Preview Page Rules (ChatGPT Feedback)
- **No refactors in preview/page.tsx** unless tests are added/updated first.
- **Any change touching**:
  - `preview/page.tsx`
  - `/api/ai-astrology/generate-report`
  - subscription routes
  must pass: `npm run ci:critical` locally.
- **Never add new import path** without updating the "build-imports" test.
- **Polling loops may only terminate on**: abort signal, unmount, attemptKey changed, completed/failed state.
- **Do not use UI state** (`isProcessingUI`, `isProcessingUIRef`) to stop polling - UI state can flip during first-load.
- **Timer monotonic**: never clear `loadingStartTimeRef.current` during active generation attempt.

### Single Orchestration Owner Rule (ChatGPT Feedback - CRITICAL)
- **ONE owner for generation start**: Only ONE code path is allowed to call `generationController.start()` automatically.
- **No premature auto-recovery**: Auto-recovery must ONLY run when:
  - `generationController.status === "error"` OR `elapsedSeconds > 120`
  - AND `hasAutoGeneratedRef.current === true` (actual attempt happened)
  - AND it has not already auto-recovered
  - NEVER on first load (fresh session)
- **Recovery is manual only**: Recovery is now ONLY available via manual "Retry" button - never automatic on first load.
- **No multiple auto-start mechanisms**: Do NOT add:
  - Auto-recovery useEffect that starts generation
  - Multiple auto-generate effects that race
  - Overlapping triggers (paid report setTimeout start + verify callback start + recovery start)
- **Singleflight guard required**: Any call to `generationController.start()` must be behind a singleflight guard (e.g., `startGenerationOnce(reason)`).
- **Why this rule exists**: Multiple auto-start mechanisms race on first load, causing timer resets and stuck states. Only one owner prevents this.

### Single Orchestrator Rule (ChatGPT Feedback - CRITICAL - UPDATED)
- **Preview page must use exactly ONE orchestrator (controller)**: No legacy generation/polling logic allowed.
- **session_id is NOT state**: UI must NOT use URL params (`session_id`, `reportId`, `auto_generate`) to infer processing state.
- **Processing state must come from controller status ONLY**: `isProcessingUI` must be driven by:
  - Controller status: `["verifying", "generating", "polling"].includes(controller.status)` (when using controller)
  - Bundle processing: `bundleType && bundleReports.length > 0 && bundleGenerating` (temporary legacy path, gated to bundles only)
  - NEVER from URL params (session_id, reportId, auto_generate)
- **Bundle processing gate**: `bundleProcessing` can ONLY affect bundle reports. If `bundleProcessing` is true but `reportType` is not a bundle, log invariant violation.
- **Invariant**: If `processing === false`, UI must NEVER show "Generating...", even if URL contains `session_id`.
- **ReturnTo contract**: Any page that redirects to `/ai-astrology/input` must be returned back to `returnTo` after submission.
- **Invariant tests are blocking**: `test:critical` must include:
  - `critical-first-load-paid-session.spec.ts` (first-load paid session generation)
  - `stale-session-retry.spec.ts` (stale session handling)
  - `preview-no-processing-without-start.spec.ts` (session_id ≠ processing canary)
  - `subscription-returnTo.spec.ts` (subscription returnTo loop)
- **If Cursor changes preview/subscription/input**: Must run `npm run test:critical` and paste output into `CURSOR_PROGRESS.md`.

### Technical Debt (Tracked for Future Refactor)
- **setTimeout autostart** (preview/page.tsx, line ~1242):
  - **Status**: ✅ Guarded and documented, acceptable for production
  - **Guards**: `hasAutoGeneratedRef.current`, early returns, cleanup on unmount, never re-scheduled
  - **TODO**: Replace with `useEffect(() => startIfNeeded(), [attemptKey, auto_generate])` for better determinism
  - **Rationale**: Refactoring now risks re-introducing first-load races. Tests will catch regressions if guards fail.
  - **Do NOT refactor casually**: This is tracked technical debt. Any refactor must:
    - Include comprehensive E2E tests
    - Verify no regressions in first-load scenarios
    - Update this TODO with completion date

### Production Serverless Rules (ChatGPT Feedback - CRITICAL)
- **Single-surface changes**: one bug = one subsystem. No refactors unless requested.
- **No UI timer tweaks until API lifecycle is proven**: fix server first, then UI.
- **Serverless timeout config**: Any route that can exceed default execution time MUST export:
  - `export const runtime = "nodejs";`
  - `export const maxDuration = 180;` (or higher for complex reports)
  - `export const dynamic = "force-dynamic";`
- **Heartbeat required**: Long-running generation MUST update `updated_at` every 15-20s to prevent stuck "processing" status.
- **Always mark failed on error**: Catch/finally MUST call `markStoredReportFailed` to prevent reports stuck in "processing".
- **Every change must pass, locally**:
  - `npm run type-check`
  - `npm run build`
  - `npm run test:critical` (Playwright critical invariants)
- **If a fix touches routing/session/subscription**: it must add/adjust an E2E test.
- **If any one of these fails**: stop and write in `CURSOR_ACTIONS_REQUIRED.md` rather than "try random fixes".

### Build & Environment Rules (ChatGPT Feedback - CRITICAL)
- **Never conclude "not code issue" without proof**: Only claim sandbox/environment restriction if:
  - Failure is reproducible on a known-good runner (local/CI) AND
  - Code path reads forbidden resources (provide exact file+line for every EPERM cause)
- **Build must NOT require .env.local**: Next.js builds should succeed without `.env.local` file. Use `process.env.*` only, validate via `.env.example` + schema (zod/envalid), never `fs.readFileSync(".env.local")`.
- **VAPID key dependency**: Push/VAPID key must read ONLY from `process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY`. If not present: disable push features gracefully (no crash, no build fail).
- **Test stages split correctly**: Tests must be split into independent gates:
  - `test:unit` (no network)
  - `test:integration` (mock external network)
  - `test:e2e` (only in CI runners that support browsers - can be skipped safely when unsupported)
- **When claiming EPERM/sandbox**: Must provide exact file+line where code tries to read restricted resource. No proof = no acceptance.

### If the model/provider fails (Try again / Resume)
- Retry with exponential backoff: **30s, 60s, 120s** (3 attempts total).
- If still failing after 3 retries:
  - Write exact pending steps into `CURSOR_ACTIONS_REQUIRED.md` and stop.
  - Include: file names, change intent, why it is safe, exact next commands.
  - Do NOT continue making changes after connection error without logging.
- Never block waiting for the user; keep progressing on non-blocked work.
- **Root cause fixes** (to prevent connection errors):
  - Check VPN/proxy settings (disable or allowlist Cursor + API provider domains).
  - Verify OpenAI key rate limit/quota/billing/model mismatch.
  - Reduce concurrent agent actions: keep to 1–2 parallel tasks max.

### Approvals (hard stops)
- Always ask before:
  - running terminal commands (unless they match an allowlist you already trust),
  - installing dependencies,
  - deleting files,
  - editing secrets/env files,
  - any network/external API access,
  - **git push** (commits are fine, but always get approval before push).

### When an approval/popup appears (Confirm edit / Accept / Resume / Try again)
- **CRITICAL (ChatGPT Feedback)**: Do NOT ask for clicks repeatedly.
- If "Confirm edit" / "Accept" prompt appears:
  - **STOP making further changes** immediately.
  - Write summary to `CURSOR_ACTIONS_REQUIRED.md` including:
    - File name(s)
    - Change intent
    - Why it is safe
    - Exact next steps after acceptance
  - Wait for a single "Accept", then continue automatically with the next steps.
  - **Consolidate all pending edits into ONE accept step** when possible.
- If "Connection Error" / "Resume" / "Try again" appears:
  - Retry with exponential backoff (30s, 60s, 120s).
  - If still failing: write exact pending steps into `CURSOR_ACTIONS_REQUIRED.md` and stop.
- If it's optional: **skip it** and continue.
- If it blocks progress (common in auth flows): record it in `CURSOR_ACTIONS_REQUIRED.md` with:
  - what prompt appeared,
  - where (which screen/tool),
  - what exact click/setting is needed,
  - why it's needed.
  - the safest alternative (e.g., "Open in browser" for auth) if available.

### Mandatory logging
- After each batch, update `CURSOR_PROGRESS.md`:
  - what changed,
  - what remains,
  - what is blocked + the minimal approval needed.
- **After each successful green CI gate**: Update `CURSOR_PROGRESS.md` with:
  - what changed,
  - which tests passed.
- **Run checkpoint script**: After every change, run `bash scripts/cursor-checkpoint.sh` (if available).
  - This runs: typecheck → build → critical tests
  - Writes output + next steps into `CURSOR_PROGRESS.md`
  - If failure: writes "what to do next" into `CURSOR_ACTIONS_REQUIRED.md`

### Release Gate (ChatGPT Feedback - CRITICAL)
- **Before declaring production-ready**: Must run `npm run release:gate` and paste output into `CURSOR_PROGRESS.md`.
- **release:gate** runs: `npm run type-check && npm run build && npm run test:critical`
- **Rationale**: Prevents future "it passed type-check so it's fine" mistakes.
- **Do NOT skip**: Since Cursor sometimes only runs type-check, this ensures all critical checks pass.
- **ChatGPT Verdict**: "This alone will save you days in the future." - Do not change.

### Baseline Freeze (ChatGPT Feedback - CRITICAL)
- **Current Baseline**: 2026-01-17 (Ship-ready baseline established)
- **Freeze Policy**:
  - ✅ No refactors of core flows (preview generation, subscription, polling)
  - ✅ No "cleanup" without explicit approval
  - ✅ Only additive features allowed
  - ✅ Any core flow change must pass `npm run release:gate`
- **Technical Debt**: setTimeout autostart is tracked but NOT refactored yet (do not change casually)
- **ChatGPT Verdict**: "You've turned a fragile, emergent system into a governed, deterministic one."

### Stabilization Mode (ChatGPT Feedback - CRITICAL)
**If the user says "run all tests" or "stabilize build":**
- Enter **Stabilization Mode**
- Follow PHASE 0 → PHASE 4 exactly
- Do not exit early

**PHASE 0 — Freeze Scope**:
- ❌ Do NOT add new features
- ❌ Do NOT refactor unrelated code
- ❌ Do NOT change UI copy/styles
- ✅ Only fix what is required to pass tests and stabilize runtime behavior

**PHASE 1 — Full Test Execution (Mandatory)**:
Run all of the following, in order (do NOT skip any step):
1. `npm run type-check`
2. `npm run build`
3. `npm run test`
4. `npm run test:critical`
5. `npm run ci:critical`

**PHASE 2 — Failure-Driven Fix Loop**:
For each failure:
1. **Identify**:
   - ❓ Is the test wrong? (flaky, outdated, missing invariant)
   - ❓ Or is the code wrong? (regression, race condition, broken contract)
2. **Apply minimal fix**:
   - Change ≤ 5 files
   - Touch only files directly involved in the failure
3. **If a test failed to catch a real bug**:
   - Enhance the test to cover the real user-journey invariant
   - Never weaken assertions
4. **Re-run all tests again from Phase 1**

Repeat until everything passes.

**PHASE 3 — Runtime Stability Verification**:
After tests pass:
- Manually simulate (code-level, not browser clicks):
  - First-load report generation
  - Polling convergence (processing → complete/failed)
  - Subscription create → verify → cancel
- Confirm no infinite loops, no timer resets, no silent exits

**PHASE 4 — Lock the Win**:
When stable:
1. Update `CURSOR_PROGRESS.md`:
   - What failed
   - What changed
   - What fixed it
2. Update `CURSOR_ACTIONS_REQUIRED.md`:
   - Only if human action is required (keys, Stripe dashboard, etc.)
3. **STOP** - Do not continue improving or refactoring

**ABSOLUTE NON-NEGOTIABLE RULES**:
- If any test fails → you are NOT done
- If build fails → revert and fix
- If a fix breaks another test → revert and re-iterate
- Never silence errors
- Never bypass CI gates
- Never assume "second load works" is acceptable

**Success condition**: `npm run ci:critical` passes AND no infinite loading states are possible.
