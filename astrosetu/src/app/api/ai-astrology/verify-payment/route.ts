import { NextResponse } from "next/server";
import { checkRateLimit, handleApiError } from "@/lib/apiHelpers";
import { generateRequestId } from "@/lib/requestId";
import { isStripeConfigured } from "@/lib/ai-astrology/payments";
import { generatePaymentToken } from "@/lib/ai-astrology/paymentToken";
import {
  upsertSubscriptionFromStripe,
  derivePlanIntervalFromStripe,
  mapStripeStatus,
  getCurrentPeriodEndIsoFromStripe,
} from "@/lib/billing/subscriptionStore";

/**
 * GET /api/ai-astrology/verify-payment?session_id=xxx
 * Verify Stripe payment session
 */
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  const requestId = generateRequestId();

  try {
    // Rate limiting
    const rateLimitResponse = checkRateLimit(req, "/api/ai-astrology/verify-payment");
    if (rateLimitResponse) {
      rateLimitResponse.headers.set("X-Request-ID", requestId);
      return rateLimitResponse;
    }

    // Get session ID from query params
    const { searchParams } = new URL(req.url);
    const sessionId = searchParams.get("session_id");

    if (!sessionId) {
      return NextResponse.json(
        { ok: false, error: "session_id is required" },
        { status: 400 }
      );
    }

    // Check for test session (mock payment for demo/test mode)
    // MVP FIX: Lock production payment behavior - avoid accidental bypass
    const isDemoTestSession = sessionId.startsWith("test_session_");
    const isProdTestSession = sessionId.startsWith("prodtest_");
    const isProd = process.env.VERCEL_ENV === "production";
    const allowProdTestBypass = process.env.ALLOW_PROD_TEST_BYPASS === "true";
    
    // MVP FIX: Do NOT auto-bypass Stripe for prodtest_ unless ALLOW_PROD_TEST_BYPASS=true
    // test_session_ always bypasses (demo mode)
    // prodtest_ bypasses only if explicitly allowed OR not in production
    const shouldBypassProdTest = isProdTestSession && (allowProdTestBypass || !isProd);
    const isTestSession = isDemoTestSession || shouldBypassProdTest;
    
    // Handle test sessions as mock - they should NEVER go to Stripe
    // Test sessions are generated by create-checkout for demo/test users
    if (isTestSession) {
      const sessionType = isProdTestSession ? "PROD_TEST" : "DEMO";
      console.log(`[TEST SESSION] Verifying ${sessionType} session: ${sessionId} (bypassing Stripe)`);
      
      // Extract reportType from session ID (format: {prefix}_{reportType}_{requestId})
      // Note: reportType may contain hyphens, so we need to extract it carefully
      let extractedReportType = "marriage-timing"; // Default
      let isSubscriptionTest = false;
      
      const sessionPrefix = isProdTestSession ? "prodtest_" : "test_session_";
      if (sessionId.startsWith(sessionPrefix)) {
        const afterPrefix = sessionId.substring(sessionPrefix.length);
        // Find the last underscore to separate reportType from requestId
        // The requestId format is "req-{timestamp}-{random}-{counter}" (uses hyphens, not underscores)
        // So there should be exactly one underscore - the one between reportType and requestId
        const lastUnderscoreIndex = afterPrefix.lastIndexOf("_");
        
        if (lastUnderscoreIndex > 0) {
          const typePart = afterPrefix.substring(0, lastUnderscoreIndex);
          if (typePart === "subscription") {
            isSubscriptionTest = true;
          } else {
            // Check all valid report types (including those with hyphens like "decision-support", "major-life-phase", "year-analysis")
            const validReportTypes = ["marriage-timing", "career-money", "full-life", "year-analysis", "major-life-phase", "decision-support"];
            if (validReportTypes.includes(typePart)) {
              extractedReportType = typePart;
            } else {
              // Log warning if reportType couldn't be extracted (for debugging)
              console.warn(`[verify-payment] Could not extract valid reportType from session ID. Extracted: "${typePart}", Session ID: ${sessionId}`);
            }
          }
        } else {
          // Log warning if underscore not found (for debugging)
          console.warn(`[verify-payment] Could not find underscore separator in session ID: ${sessionId}`);
        }
      }
      
      return NextResponse.json(
        {
          ok: true,
          data: {
            sessionId,
            paid: true,
            paymentStatus: "paid",
            subscription: isSubscriptionTest,
            reportType: isSubscriptionTest ? undefined : extractedReportType,
            paymentToken: undefined, // Test sessions don't need payment tokens (generate-report handles test users)
            customerEmail: undefined,
            amountTotal: 1, // Test amount in cents
            currency: "aud",
            metadata: { testMode: true },
          },
          requestId,
        },
        {
          headers: {
            "X-Request-ID": requestId,
            "Cache-Control": "no-cache",
          },
        }
      );
    }

    // Check if Stripe is configured for real payments
    if (!isStripeConfigured()) {
      return NextResponse.json(
        { ok: false, error: "Payment processing not configured" },
        { status: 503 }
      );
    }

    // Dynamically import Stripe
    const Stripe = (await import("stripe")).default;
    
    // Validate that we have a secret key (not publishable key)
    const secretKey = process.env.STRIPE_SECRET_KEY;
    if (!secretKey || secretKey.startsWith("pk_")) {
      console.error("[verify-payment] Invalid STRIPE_SECRET_KEY: Must be a secret key (sk_...) not a publishable key (pk_...)");
      return NextResponse.json(
        { ok: false, error: "Payment processing configuration error. Please check server configuration." },
        { status: 500 }
      );
    }
    
    const stripe = new Stripe(secretKey);

    // Retrieve session
    let session;
    try {
      session = await stripe.checkout.sessions.retrieve(sessionId);
    } catch (stripeError: any) {
      const stripeRetrieveError = {
        requestId,
        timestamp: new Date().toISOString(),
        sessionId: sessionId.substring(0, 20) + "...",
        errorType: stripeError.constructor?.name || "Unknown",
        errorMessage: stripeError.message || "Unknown error",
        errorCode: stripeError.code || "N/A",
        stripeErrorType: stripeError.type || "N/A",
      };
      console.error("[STRIPE SESSION RETRIEVE ERROR]", JSON.stringify(stripeRetrieveError, null, 2));
      
      return NextResponse.json(
        { ok: false, error: "Failed to retrieve payment session. Please contact support." },
        { status: 500 }
      );
    }

    if (!session) {
      const sessionNotFoundError = {
        requestId,
        timestamp: new Date().toISOString(),
        sessionId: sessionId.substring(0, 20) + "...",
        error: "Session not found in Stripe",
      };
      console.error("[SESSION NOT FOUND]", JSON.stringify(sessionNotFoundError, null, 2));
      
      return NextResponse.json(
        { ok: false, error: "Session not found" },
        { status: 404 }
      );
    }
    
    // Get payment intent ID from session (for manual capture) - check this first
    let paymentIntentId: string | undefined;
    let paymentIntentStatus: string | undefined;
    if (session.payment_intent) {
      if (typeof session.payment_intent === "string") {
        paymentIntentId = session.payment_intent;
      } else {
        paymentIntentId = session.payment_intent.id;
      }
      
      // For manual capture, check the payment intent status
      // If we have a payment intent, retrieve it to check actual status
      if (paymentIntentId) {
        try {
          const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
          paymentIntentStatus = paymentIntent.status;
        } catch (piError: any) {
          console.warn(`[verify-payment] Could not retrieve payment intent ${paymentIntentId}:`, piError.message);
          // Continue - we'll use session status as fallback
        }
      }
    }

    // Log successful session retrieval
    const sessionRetrieved = {
      requestId,
      timestamp: new Date().toISOString(),
      sessionId: session.id.substring(0, 20) + "...",
      paymentStatus: session.payment_status,
      paymentIntentStatus: paymentIntentStatus || "N/A",
      mode: session.mode,
      reportType: session.metadata?.reportType || "N/A",
      amountTotal: session.amount_total,
      currency: session.currency,
    };
    console.log("[PAYMENT SESSION RETRIEVED]", JSON.stringify(sessionRetrieved, null, 2));

    // Check payment status
    // CRITICAL: For manual capture, payment_status might be "unpaid" even if payment is authorized
    // We need to check both session.payment_status AND payment intent status
    const isPaid = 
      session.payment_status === "paid" || 
      (paymentIntentStatus !== undefined && paymentIntentStatus === "requires_capture") || // Manual capture - payment authorized but not captured yet
      (paymentIntentStatus !== undefined && paymentIntentStatus === "succeeded"); // Payment already captured
    
    const isSubscription = session.mode === "subscription";
    const reportType = session.metadata?.reportType;

    // Generate payment token if payment is successful/authorized and it's a paid report
    let paymentToken: string | undefined;
    if (isPaid && reportType && reportType !== "subscription") {
      paymentToken = generatePaymentToken(reportType, session.id);
    }

    // If this is a subscription checkout and it's paid/authorized, persist subscription state (best-effort)
    // This makes "Manage Subscription" work immediately after success redirect, even before webhook processing.
    if (isPaid && isSubscription && session.subscription) {
      try {
        const subId = typeof session.subscription === "string" ? session.subscription : session.subscription.id;
        const sub = await stripe.subscriptions.retrieve(subId);
        await upsertSubscriptionFromStripe({
          sessionId: session.id,
          stripeCustomerId: (session.customer as any) ? String(session.customer) : null,
          stripeSubscriptionId: subId,
          status: mapStripeStatus(sub.status),
          cancelAtPeriodEnd: !!sub.cancel_at_period_end,
          currentPeriodEndIso: getCurrentPeriodEndIsoFromStripe(sub),
          planInterval: derivePlanIntervalFromStripe(sub),
        });
      } catch (e) {
        // Non-blocking
      }
    }

    return NextResponse.json(
      {
        ok: true,
        data: {
          sessionId: session.id,
          paid: isPaid,
          paymentStatus: session.payment_status,
          paymentIntentStatus: paymentIntentStatus, // Include payment intent status for manual capture
          subscription: isSubscription,
          reportType,
          paymentToken, // Include token for client to store
          paymentIntentId, // CRITICAL: For manual capture after report generation
          customerEmail: session.customer_email,
          amountTotal: session.amount_total,
          currency: session.currency,
          metadata: session.metadata,
        },
        requestId,
      },
      {
        headers: {
          "X-Request-ID": requestId,
          "Cache-Control": "no-cache",
        },
      }
    );
  } catch (error: any) {
    // COMPREHENSIVE ERROR LOGGING for payment verification
    const verifyErrorContext = {
      requestId,
      timestamp: new Date().toISOString(),
      sessionId: new URL(req.url).searchParams.get("session_id")?.substring(0, 20) + "..." || "N/A",
      errorType: error.constructor?.name || "Unknown",
      errorMessage: error.message || "Unknown error",
      errorStack: error.stack || "No stack trace",
    };
    
    console.error("[PAYMENT VERIFICATION ERROR]", JSON.stringify(verifyErrorContext, null, 2));
    
    const errorResponse = handleApiError(error);
    errorResponse.headers.set("X-Request-ID", requestId);
    return errorResponse;
  }
}

