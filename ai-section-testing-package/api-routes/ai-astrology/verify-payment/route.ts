import { NextResponse } from "next/server";
import { checkRateLimit, handleApiError } from "@/lib/apiHelpers";
import { generateRequestId } from "@/lib/requestId";
import { isStripeConfigured } from "@/lib/ai-astrology/payments";
import { generatePaymentToken } from "@/lib/ai-astrology/paymentToken";

/**
 * GET /api/ai-astrology/verify-payment?session_id=xxx
 * Verify Stripe payment session
 */
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  const requestId = generateRequestId();

  try {
    // Rate limiting
    const rateLimitResponse = checkRateLimit(req, "/api/ai-astrology/verify-payment");
    if (rateLimitResponse) {
      rateLimitResponse.headers.set("X-Request-ID", requestId);
      return rateLimitResponse;
    }

    // Get session ID from query params
    const { searchParams } = new URL(req.url);
    const sessionId = searchParams.get("session_id");

    if (!sessionId) {
      return NextResponse.json(
        { ok: false, error: "session_id is required" },
        { status: 400 }
      );
    }

    // Check for test session (mock payment for demo/test mode)
    const isTestSession = sessionId.startsWith("test_session_");
    
    // ALWAYS handle test sessions as mock - they should NEVER go to Stripe
    // Test sessions are generated by create-checkout for demo/test users
    if (isTestSession) {
      console.log(`[TEST SESSION] Verifying test session: ${sessionId} (bypassing Stripe)`);
      
      // Extract reportType from session ID (format: test_session_{reportType}_{requestId})
      // Note: reportType may contain hyphens, so we need to extract it carefully
      let extractedReportType = "marriage-timing"; // Default
      let isSubscriptionTest = false;
      
      const sessionPrefix = "test_session_";
      if (sessionId.startsWith(sessionPrefix)) {
        const afterPrefix = sessionId.substring(sessionPrefix.length);
        // Find the last underscore to separate reportType from requestId
        // The requestId format is "req-{timestamp}-{random}-{counter}" (uses hyphens, not underscores)
        // So there should be exactly one underscore - the one between reportType and requestId
        const lastUnderscoreIndex = afterPrefix.lastIndexOf("_");
        
        if (lastUnderscoreIndex > 0) {
          const typePart = afterPrefix.substring(0, lastUnderscoreIndex);
          if (typePart === "subscription") {
            isSubscriptionTest = true;
          } else {
            // Check all valid report types (including those with hyphens like "decision-support", "major-life-phase", "year-analysis")
            const validReportTypes = ["marriage-timing", "career-money", "full-life", "year-analysis", "major-life-phase", "decision-support"];
            if (validReportTypes.includes(typePart)) {
              extractedReportType = typePart;
            } else {
              // Log warning if reportType couldn't be extracted (for debugging)
              console.warn(`[verify-payment] Could not extract valid reportType from session ID. Extracted: "${typePart}", Session ID: ${sessionId}`);
            }
          }
        } else {
          // Log warning if underscore not found (for debugging)
          console.warn(`[verify-payment] Could not find underscore separator in session ID: ${sessionId}`);
        }
      }
      
      return NextResponse.json(
        {
          ok: true,
          data: {
            sessionId,
            paid: true,
            paymentStatus: "paid",
            subscription: isSubscriptionTest,
            reportType: isSubscriptionTest ? undefined : extractedReportType,
            paymentToken: undefined, // Test sessions don't need payment tokens (generate-report handles test users)
            customerEmail: undefined,
            amountTotal: 1, // Test amount in cents
            currency: "aud",
            metadata: { testMode: true },
          },
          requestId,
        },
        {
          headers: {
            "X-Request-ID": requestId,
            "Cache-Control": "no-cache",
          },
        }
      );
    }

    // Check if Stripe is configured for real payments
    if (!isStripeConfigured()) {
      return NextResponse.json(
        { ok: false, error: "Payment processing not configured" },
        { status: 503 }
      );
    }

    // Dynamically import Stripe
    const Stripe = (await import("stripe")).default;
    
    // Validate that we have a secret key (not publishable key)
    const secretKey = process.env.STRIPE_SECRET_KEY;
    if (!secretKey || secretKey.startsWith("pk_")) {
      console.error("[verify-payment] Invalid STRIPE_SECRET_KEY: Must be a secret key (sk_...) not a publishable key (pk_...)");
      return NextResponse.json(
        { ok: false, error: "Payment processing configuration error. Please check server configuration." },
        { status: 500 }
      );
    }
    
    const stripe = new Stripe(secretKey);

    // Retrieve session
    const session = await stripe.checkout.sessions.retrieve(sessionId);

    if (!session) {
      return NextResponse.json(
        { ok: false, error: "Session not found" },
        { status: 404 }
      );
    }

    // Check payment status
    const isPaid = session.payment_status === "paid";
    const isSubscription = session.mode === "subscription";
    const reportType = session.metadata?.reportType;

    // Generate payment token if payment is successful and it's a paid report
    let paymentToken: string | undefined;
    if (isPaid && reportType && reportType !== "subscription") {
      paymentToken = generatePaymentToken(reportType, session.id);
    }

    return NextResponse.json(
      {
        ok: true,
        data: {
          sessionId: session.id,
          paid: isPaid,
          paymentStatus: session.payment_status,
          subscription: isSubscription,
          reportType,
          paymentToken, // Include token for client to store
          customerEmail: session.customer_email,
          amountTotal: session.amount_total,
          currency: session.currency,
          metadata: session.metadata,
        },
        requestId,
      },
      {
        headers: {
          "X-Request-ID": requestId,
          "Cache-Control": "no-cache",
        },
      }
    );
  } catch (error) {
    const errorResponse = handleApiError(error);
    errorResponse.headers.set("X-Request-ID", requestId);
    return errorResponse;
  }
}

